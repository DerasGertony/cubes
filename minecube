import pygame
from pygame.locals import *
#pip install PyOpenGL PyOpenGL_accelerate
from OpenGL.GL import *
from OpenGL.GLU import *
from math import sin, cos, radians
from ctypes import windll
import numpy as np
from perlin_noise import PerlinNoise
class worldgen():
    def __init__(self,size):
        pass
class main():
    def __init__(self, blocks):
        self.world = blocks
        self.vertices = (
            ( 0.5, -0.5, -0.5),
            ( 0.5,  0.5, -0.5),
            (-0.5,  0.5, -0.5),
            (-0.5, -0.5, -0.5),
            ( 0.5, -0.5,  0.5),
            ( 0.5,  0.5,  0.5),
            (-0.5, -0.5,  0.5),
            (-0.5,  0.5,  0.5),
            )
        self.surfaces = ((0,1,2,3),(3,2,7,6),(6,7,5,4),(4,5,1,0),(1,5,7,2),(4,0,3,6),)
        self.normals = ((0, 0, -1),(-1, 0, 0),(0, 0, 1),(1, 0, 0),(0, 1, 0),(0, -1, 0))
        self.edges = ((3,0),(3,2),(3,6),(5,1),(5,4),(5,7),(0,1),(0,4),(1,2),(2,7),(4,6),(6,7))
        pygame.init()
        info = pygame.display.Info()
        self.fscreen = False
        self.fsize = info.current_w, info.current_h
        self.size = 1600, 900
        self.screen = pygame.display.set_mode(self.size, DOUBLEBUF | OPENGL)
        GL_TEXTURE_3D
        glEnable(GL_DEPTH_TEST)
        glEnable(GL_LIGHTING)
        glShadeModel(GL_SMOOTH)
        glEnable(GL_COLOR_MATERIAL)
        glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE)
        glEnable(GL_LIGHT0)
        glLightfv(GL_LIGHT0, GL_AMBIENT, [0.5, 0.5, 0.5, 1])
        glLightfv(GL_LIGHT0, GL_DIFFUSE, [1.0, 1.0, 1.0, 1])
        self.sphere = gluNewQuadric() 
        glMatrixMode(GL_PROJECTION)
        gluPerspective(120, (16/9), 0.1, 50.0)
        glMatrixMode(GL_MODELVIEW)
        gluLookAt(0, 1, 0, 0, 0, 0, 0, 0, 1)
        self.viewMatrix = glGetFloatv(GL_MODELVIEW_MATRIX)
        glLoadIdentity()
        # init mouse movement and center mouse on screen
        self.displayCenter = [self.screen.get_size()[i] // 2 for i in range(2)]
        self.mouseMove = [0, 0]
        pygame.mouse.set_pos(self.displayCenter)
        pygame.time.set_timer(pygame.USEREVENT, 100)
        self.up_down_angle = 0.0
        self.paused = False
        self.run = True
        self.reset = 0
        self.clock = pygame.time.Clock()
        self.jump = [-59/6*i/60+5*(i/60)**2 for i in range(0,11)]
        self.jump = [0] + [self.jump[i]-self.jump[i-1] for i in range(1,11)]
        self.fall = [0] + [-self.jump[i] for i in range(1, 11)][::-1]
        self.curjump = 0
        self.pos = [0,0,0,0]
        self.loop()
    def Cube(self):
        glBegin(GL_QUADS)
        for i_surface, surface in enumerate(self.surfaces):
            #glNormal3fv(self.normals[i_surface]) # set the normal vector the vertices of the surface
            for vertex in surface:
                glVertex3fv(self.vertices[vertex])
        glEnd()
        glBegin(GL_LINES)
        glColor3f(0,0,0)
        for edge in self.edges:
            for index in edge:
                glVertex3fv(self.vertices[index])
        glEnd()
    def loop(self):
        while self.run:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.run = False
                if event.type == pygame.USEREVENT:
                    pass
                    #print(1)
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_f:
                        self.fscreen = not self.fscreen
                        if self.fscreen:
                            pygame.display.toggle_fullscreen()
                        else:
                            hwnd = pygame.display.get_wm_info()['window']
                            self.screen = pygame.display.set_mode(self.size, DOUBLEBUF | OPENGL)
                            windll.user32.MoveWindow(hwnd, (self.fsize[0]-self.size[0])//2, (self.fsize[1]-self.size[1])//2, self.size[0], self.size[1], False)
                    if event.key == pygame.K_ESCAPE or event.key == pygame.K_RETURN:
                        self.run = False
                    if event.key == pygame.K_p:
                        self.paused = not self.paused
                        pygame.mouse.set_cursor(0)
                        pygame.mouse.set_pos(self.displayCenter)
                if not self.paused and event.type == pygame.MOUSEMOTION:
                        self.mouseMove = [event.pos[i] - self.displayCenter[i] for i in range(2)]
                        pygame.mouse.set_pos(self.displayCenter)    
            if self.paused and not self.reset:
                self.paused = False
                pass
            if self.reset == 60:
                self.reset = 0
                self.paused = True
            if not self.paused:
                pygame.mouse.set_cursor((8,8),(0,0),(0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0))
                self.screen.fill(pygame.Color(0,255,255))
                # get keys
                keypress = pygame.key.get_pressed()
                # init model view matrix
                glLoadIdentity()
                # apply the look up and down
                self.up_down_angle += self.mouseMove[1]
                if self.up_down_angle > 90:
                    self.up_down_angle = 90
                if self.up_down_angle < -90:
                    self.up_down_angle = -90
                glRotatef(self.up_down_angle, 1.0, 0.0, 0.0)
                # init the view matrix
                glPushMatrix()
                glLoadIdentity()
                # apply the movement
                mov = [0,0,0]
                if keypress[pygame.K_w]:
                    mov[2] += 0.08
                if keypress[pygame.K_s]:
                    mov[2] -= 0.08
                if keypress[pygame.K_d]:
                    mov[0] -= 0.08
                if keypress[pygame.K_a]:
                    mov[0] += 0.08
                if mov[0] != 0 and mov[2] != 0:
                    mov[0] /= 2**0.8
                    mov[2] /= 2**0.8
                if keypress[pygame.K_LSHIFT]:
                    mov[2] *= 1.6
                    mov[0] *= 1.6
                self.pos[3] += self.mouseMove[0]
                ix, iz, iy = round(self.pos[0]), round(self.pos[2]), round(self.pos[1])
                g = np.array(self.world)
                g = g[g[::,0] >= ix-1]
                g = g[g[::,0] <= ix+1]
                g = g[g[::,1] >= iz-1]
                g = g[g[::,1] <= iz+1]
                g = g[g[::,2] <= -iy + 2]
                g = g[g[::,2] > -iy]
                dt = [self.pos[0],self.pos[2]]
                dt[0] -= mov[0]*sin(radians(self.pos[3])) + mov[2]*cos(radians(self.pos[3]))
                dt[1] -= mov[2]*sin(radians(self.pos[3])) - mov[0]*cos(radians(self.pos[3]))
                #print(self.pos, dt[0], [(i+0.5, i-0.5) for i in g[::,0]])
                #collision?
                '''if any([dt[0]<i+0.5 and dt[0]>i-0.5 for i in g[::,0]]):
                    print('in') 
                else:
                    self.pos[0] = dt[0]
                if any([dt[1]<i+0.5 and dt[1]>i-0.5 for i in g[::,2]]):
                    print('in') 
                else:
                    self.pos[2] = dt[1]'''
                self.pos[0] = dt[0]
                self.pos[2] = dt[1]
                ix, iz, iy = round(self.pos[0]), round(self.pos[2]), round(self.pos[1])
                g = np.array(self.world)
                g = g[g[::,0] == ix]
                g = g[g[::,1] == iz]
                g = g[g[::,2] <= -iy + 1 - 1e-7]                
                g = sorted(g, key=lambda x: x[2])[-1]
                if keypress[pygame.K_SPACE] and not self.curjump and -1e-7 < self.pos[1] + g[2] < 1e-7:
                    self.curjump = 1
                if self.curjump:
                    mov[1] += self.jump[self.curjump]
                    self.curjump += 1
                    self.curjump %= len(self.jump)
                if not mov[1] and -self.pos[1] > g[2]:
                    self.falling = max(1,self.falling)
                else:
                    self.falling = 0
                if self.falling:
                    mov[1] = min(-self.pos[1] - g[2], self.fall[self.falling])
                    self.falling = min(self.falling+1, 10)
                #print(g, self.pos, self.curjump, mov[1])
                glTranslate(*mov)
                self.pos[1] += mov[1]
                # apply the left and right rotation
                glRotatef(self.mouseMove[0], 0.0, 1.0, 0.0)
                # multiply the current matrix by the get the new view matrix and store the final view matrix 
                glMultMatrixf(self.viewMatrix)
                self.viewMatrix = glGetFloatv(GL_MODELVIEW_MATRIX)
                # apply view matrix
                glPopMatrix() 
                glMultMatrixf(self.viewMatrix)
                glLightfv(GL_LIGHT0, GL_POSITION, [0, 0, 256, 0])
                glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
                glPushMatrix()
                glTranslatef(0,1,-2)
                cur = 0
                for i in self.world:
                    if (i[0]-self.pos[0])**2 + (i[1]-self.pos[2])**2 + (-self.pos[1]-i[2])**2 > 12:
                        continue
                    cur += 1
                    glTranslatef(i[1],i[0],i[2])
                    glColor3f(0,0.5,0)
                    self.Cube()
                    glTranslatef(-i[1],-i[0],-i[2])
                glPopMatrix()
                self.reset += 1
                pygame.display.flip()
            self.clock.tick(62)
            print(f'fps:{self.clock.get_fps()}')
        pygame.quit()
blocks = [[0,0,0]]
for y in range(-10,0):
    for z in range(-20,21):
        for x in range(-20,21):
            noise = PerlinNoise(octaves=16)
            if noise([(z+20)/40,(x+20)/40])>0:
                blocks.append([x,z,y])
for z in range(-40,41):
    for x in range(-40,41):
        blocks.append([x,z,-11])
print(blocks)
main(blocks)
